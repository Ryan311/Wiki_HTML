<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=cp936">
    <title>Windows Strings</title>
    <link rel="stylesheet" type="text/css" href="css/shCoreDefault.css"/>
    <link rel="Stylesheet" type="text/css" href="static/css/wiki.css">
    <link rel="Stylesheet" type="text/css" href="static/bootstrap/css/bootstrap.min.css">
    <script type="text/javascript" src="static/js/jquery.min.js"></script>
    <script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/js/wiki.js"></script>
    <script type="text/javascript" src="static/js/shCore.js"></script>
    <script type="text/javascript" src="static/js/shBrushPython.js"></script>
    <script type="text/javascript" src="static/js/shBrushCpp.js"></script>
    <script type="text/javascript" src="static/js/shBrushErlang.js"></script>
    <script type="text/javascript" src="static/js/shBrushBash.js"></script>
    <script type="text/javascript" src="static/js/shBrushRuby.js"></script>
    <script type="text/javascript" src="static/js/shBrushSql.js"></script>
    <script type="text/javascript" src="static/js/shBrushJScript.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<nav class="navbar navbar-default navbar-inverse" role="navigation">
 <div class="container">
    <div class="navbar-header">
<button data-target=".bs-navbar-collapse" data-toggle="collapse" type="button" class="navbar-toggle">
	<span class="sr-only"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
      </button>
	<a class="navbar-brand" href="main.html">Rick's wiki</a>
    </div>
    <div class="collapse navbar-collapse">
	<ul class="nav navbar-nav">
	    <li><a href="main.html">Home</a></li>
	    <li><a href="TODO.html">TODO</a></li>
	</ul>
    </div>
 </div>
</nav>
<div class="container content-body">
    
<div class="toc">
<ul>
<li><a href="#toc_1">Basic</a>
<li><a href="#toc_2">Microsoft C运行库中的字符和字符串 </a>
<li><a href="#toc_3">Windwos字符串函数 </a>
<li><a href="#toc_4">CString与string、char*的区别和转换</a>
<li><a href="#toc_5">String Header</a>
<li><a href="#toc_6">Windwos Safe String Comparison with C Run-time String</a>
</ul>
</div>

<p>
MSDN:       <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646979%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms646979%28v=vs.85%29.aspx</a>
C++ Ref:    <a href="http://www.cplusplus.com/reference/">http://www.cplusplus.com/reference/</a>
</p>

<h1 id="toc_1">Basic</h1>
<ul>
<li>
  Windows中，每个Unicode字符都使用UTF-16编码。

<li>
  Microsoft的C/C++编译器定义了一个内建的数据类型wchar_t, 它表示一个16位的Unicode(UTF-16)字符

<li>
  WinNT.h中定义了Windows中使用的数据类型：
<pre>
    typedef char CHAR;      // 8-bit character
    typedef wchar_t WCHAR;  // 16-bit character
    
    // Pointer to 8-bit character(s)
    typedef CHAR *PCHAR;
    typedef CHAR *PSTR;
    typedef CONST CHAR *PCSTR;

    // Pointer to 16-bit character(s)
    typedef WCHAR *PWCHAR;
    typedef WCHAR *PWSTR;
    typedef CONST WCHAR *PCWSTR;
    
    在编译时， 为了使ANSI或UNICODE都能编译通过， 定义如下宏：
    #ifdef UNICODE
    
        typedef WCHAR TCHAR, *PTCHAR, PTSTR;
        typedef CONST WCHAR *PCTSTR;

        #define __TEXT(quote) L##quote

    #else
        
        typedef CHAR TCHAR, *PTCHAR, PTSTR;
        typedef CONST CHAR *PCTSTR;

        #define __TEXT(quote) quote

    #endif
    
    #define TEXT(quote) __TEXT(quote)
    #define _T(quote)   __TEXT(quote)
</pre>

<li>
  Windows函数通常都会提供两个版本， ANSI和UNICODE， 用宏来统一使用方式。 ANSI版本中， 只分配内存， 执行必要的字符串转换， 然后调用该函数的UNICODE版本。所以为使用程序执行更高效， 一开始就应该使用Unicode来开发程序。

<li>
  LPTCHAR, LPTSTR, LPCTCHAR, LPCTSTR: L表示long指针， 为了兼容16位系统， 没有实际意义， LP理解为P即可

</ul>

<h1 id="toc_2">Microsoft C运行库中的字符和字符串 </h1>
<ul>
<li>
  分别提供两组函数来支持ANSI和Unicode的字符和字符串， 不像Windows函数那样存在调用关系
<pre>
    在String.h中定义的strlen, wcslen， 分别获取ANSI和UNICODE的字符串长度， 在TChar.h中定义如下宏， 方便同时编译ANSI和Unicode版本。
    #ifdef _UNICODE
        #define _tcslen     wcslen  //Unicode
    #else
        #define _tcslen     strlen  //ANSI
    #endif
</pre>

<li>
  新的安全字符串函数 

<ul>
<li>
  需要包含StrSafe.h文件

<li>
  对应于C中的每个字符串函数， 都有一个新版本函数， 添加一个_s后缀

<li>
  新版本的函数中增加了对传入参数的判断， 可检查缓冲区有效性等， 当缓冲区出现错误时， 返回Error
    | C的字符串函数 | 新的安全字符串函数 |
    | _tcscpy       | _tcscpy_s          |
    | _tcscat       | _tcscat_s          |

</ul>
<li>
  为了获得更多控制， 可使用StringC*函数

<ul>
<li>
  同样需要包含StrSafe.h文件

<li>
  Cch： Count of Characters， 由_countof宏来获得字符数

<li>
  Cb：  Count of Bytes, 由sizeof操作符获得字节数

<li>
  该系列函数返回HRESULT

<li>
  不同于安全(后缀为_s)的函数， 当缓冲区太小时， 这些函数会执行截断

</ul>
</ul>

<h1 id="toc_3">Windwos字符串函数 </h1>
<ul>
<li>
  StrFormatKbSize

<li>
  StrFormatByteSize

<li>
  ComparString(Ex)

<li>
  CompareStringOrdinal    

<li>
  MultiByteToWideChar

<li>
  WideCharToMultiByte

</ul>


<h1 id="toc_4">CString与string、char*的区别和转换</h1>
<ul>
<li>
  From    <a href="http://blog.csdn.net/luoweifu/article/details/20232379">http://blog.csdn.net/luoweifu/article/details/20232379</a>

<li>
  char*       char*是一个指向字符的指针，是一个内置类型。可以指向一个字符，也可以表示字符数组的首地址（首字符的地址）。

<li>
  string      string是C++标准库(STL)中的类型，它是定义的一个类，定义在&lt;string&gt;头文件中。里面包含了对字符串的各种常用操作，它较char*的优势是内容可以动态拓展，以及对字符串操作的方便快捷

<li>
  CString     主要应用在MFC和ATL编程中，所以使用CString时要包含afx.h文件#include &lt;afx.h&gt;

<li>
  相互的转换
<pre>
    1.  char*与string的转换
        char* --&gt; string    
            char* ch = "hello world";  
            string s1 = ch; 
            string s2(ch), s3;  
            s3 = string(ch);  
        string --&gt; char*
            /************************************************************************* 
            其实没有很大的必要将string转换成char*,因为string可以直接当成字符数组来使用， 
            即通过下标来访问字符元素，如str[1]表示第1个字符't' 
            **************************************************************************/  
            const char *ch1 = str.c_str();    

    2.  char*与CString
        char* --&gt; CString
            char *ch = "char pointer.";  
            CString cStr1 = ch;  
            CString cStr2 = CString(ch);  
        CString --&gt; char*
            char* chs=cstr.getbuffer(0)
    
    3.  CString与string
        CString --&gt; string
            CString cstr4 = "CString to string4";  
            CString cstr5 = "CString to string5";  
            string str;  
            str=cstr4.GetBuffer(0);  
            str = LPCSTR(cstr5);   
        string --&gt; CString
            string s1 = "string1 to CString";  
            string s2 = "string2 to CString";  
            string s3 = "string3 to CString";  
            CString cstr(s1.c_str());  
            CString cstr2;  
            cstr2.Format("%s", s2.c_str()); // string to CString  
            CString cstr3;  
            cstr3.Format("%s", s3.data());  // string to CString  
</pre>

<li>
  string中的c_str()和data()区别是：前者返回带'/0'的字符串，后者则返回不带'/0'的字符串.

</ul>


<h1 id="toc_5">String Header</h1>
<table>
<tr>
<td>
&lt;string.h&gt;
</td>
<td>
C的头文件，包含比如strcpy、strcat之类的字符串处理函数
</td>
</tr>
<tr>
<td>
&lt;cstring&gt;
</td>
<td>
在C++标准化(1998年)过程中，为了兼容C，标准化组织将所有C头文件都进行了新的定义，加入到标准库，文件名新增一个"c"前缀并且去掉.h的后缀名 
</td>
</tr>
<tr>
<td>
&lt;string&gt;
</td>
<td>
C++标准定义的头文件，它定义了一个string的字符串类，里面包含了string类的各种操作
</td>
</tr>
</table>

<h1 id="toc_6">Windwos Safe String Comparison with C Run-time String</h1>
<p>
String Function Comparison
<table>
<tr>
<td>
CRT String Function
</td>
<td>
strcat
</td>
<td>
strcpy
</td>
<td>
strlen
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Windows String Function
</td>
<td>
lstrcat
</td>
<td>
lstrcpy
</td>
<td>
lstrlen
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
StrSafe Function
</td>
<td>
StringCchCat
</td>
<td>
StringCchCopy
</td>
<td>
StringCchLength
</td>
</tr>
<tr>
<td>
&lt;Strsafe.h&gt;
</td>
<td>
StringCchCatEx
</td>
<td>
StringCchCopyEx
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
StringCbCat
</td>
<td>
StringCbCopy
</td>
<td>
StringCchLength
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
StringCbCatEx
</td>
<td>
StringCbCopyEx
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
StrSafe in Kernel
</td>
<td>
RtlStringCchCat
</td>
<td>
RtlStringCchCopy
</td>
<td>
RtlStringCchLength
</td>
</tr>
<tr>
<td>
&lt;ntstrsafe.h&gt;
</td>
<td>
RtlStringCchCatEx
</td>
<td>
RtlStringCchCopyEx
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
#define NTSTRSAFE_LIB
</td>
<td>
RtlStringCbCat
</td>
<td>
RtlStringCbCopy
</td>
<td>
RtlStringCchLength
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
RtlStringCbCatEx
</td>
<td>
RtlStringCbCopyEx
</td>
<td>
&nbsp;
</td>
</tr>
</table>
</p>

<p>
Features about safe string
</p>
<ul>
<li>
  每个函数以目标缓冲区所占的字节大小作为其一个输入参数，因此可以保证在写入时不会超出缓冲区末端。

<li>
  每个函数的输出字符串均以NULL结尾（null-terminate），即使该函数可能会对正确的结果进行截断。

<li>
  所有函数均有返回值，类型为NTSTATUS，只有返回STATUS_SUCCESS时，操作结果才正确。

<li>
  每个函数均有两种类型的版本，__按字节或者按字符数__。例如，StringCbCatW和StringCchCatW。

<li>
  每个函数均有支持双字节的unicode字符（以W作为后缀）和单字节的ANSI字符（以A作为后缀）的版本。例如：StringCbCatW和StringCbCatA。

<li>
  大部分函数有提供扩展版本的函数（以Ex作为后缀），例如，StringCbCatW和StringCbCatExW。

</ul>


   <hr />
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'rickhuang'; // required: replace example with your forum shortname

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</body>
</html>
