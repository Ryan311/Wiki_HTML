<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=cp936">
    <title>const</title>
    <link rel="stylesheet" type="text/css" href="css/shCoreDefault.css"/>
    <link rel="Stylesheet" type="text/css" href="static/css/wiki.css">
    <link rel="Stylesheet" type="text/css" href="static/bootstrap/css/bootstrap.min.css">
    <script type="text/javascript" src="static/js/jquery.min.js"></script>
    <script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/js/wiki.js"></script>
    <script type="text/javascript" src="static/js/shCore.js"></script>
    <script type="text/javascript" src="static/js/shBrushPython.js"></script>
    <script type="text/javascript" src="static/js/shBrushCpp.js"></script>
    <script type="text/javascript" src="static/js/shBrushErlang.js"></script>
    <script type="text/javascript" src="static/js/shBrushBash.js"></script>
    <script type="text/javascript" src="static/js/shBrushRuby.js"></script>
    <script type="text/javascript" src="static/js/shBrushSql.js"></script>
    <script type="text/javascript" src="static/js/shBrushJScript.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<nav class="navbar navbar-default navbar-inverse" role="navigation">
 <div class="container">
    <div class="navbar-header">
<button data-target=".bs-navbar-collapse" data-toggle="collapse" type="button" class="navbar-toggle">
	<span class="sr-only"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
      </button>
	<a class="navbar-brand" href="main.html">Rick's wiki</a>
    </div>
    <div class="collapse navbar-collapse">
	<ul class="nav navbar-nav">
	    <li><a href="main.html">Home</a></li>
	    <li><a href="TODO.html">TODO</a></li>
	</ul>
    </div>
 </div>
</nav>
<div class="container content-body">
    
<div class="toc">
<ul>
<li><a href="#toc_0.1">const</a>
<ul>
<li><a href="#toc_0.1.1">const Member Functions</a>
<li><a href="#toc_0.1.2">const modify function parameter</a>
<li><a href="#toc_0.1.3">const修饰成员函数的返回值 </a>
</ul>
<li><a href="#toc_0.2">volatile</a>
<li><a href="#toc_0.3">mutable</a>
</ul>
</ul>
</div>

<h2 id="toc_0.1">const</h2>
<ol>
<li>
  If you want to make sure that ptr cannot point to any other memory location
    (i.e., cannot store a different address), you can write it one of two ways:
<pre>
        Type* const ptr = &amp;vbl;
        Type* const ptr(&amp;vbl);
        
        The pointer is a const , but the addressed object can be changed.
</pre>

<li>
  If you want to make sure that the value of vbl cannot be changed by dereferencing ptr , you can write it in two ways:
<pre>
        const Type* ptr = &amp;vbl;
        const Type* ptr(&amp;vbl);
        
        In this case, the addressed object is a constant, but the pointer is not.
</pre>

<li>
  If you want to impose both kinds of protection, you can write
<pre>
        const Type* const ptr = &amp;vbl;
        const Type* const ptr(&amp;vbl);
</pre>

<li>
  Here is a good way to remember which is which: Read each of the following definitions from right to left (starting with the defined variable).
<pre>
        const char* x = &amp;p;             /* x is a pointer to const char */
        char* const y = &amp;q;             /* y is a const pointer to char */
        const char* const z = &amp;r;       /* z is a const pointer to a const char */
</pre>

</ol>

<h3 id="toc_0.1.1">const Member Functions</h3>
<ul>
<li>
  C++

<li>
  Placed after the parameter list, const becomes part of the function signature and guarantees that the function will not change the state of the host object.    const member function不能修改data member的值

</ul>


<h3 id="toc_0.1.2">const modify function parameter</h3>
<ul>
<li>
  const修饰函数参数是它最广泛的一种用途，它表示在函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)：

<ul>
<li>
  void function(const int Var);     //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用)

<li>
  void function(const char* Var);   //参数指针所指内容为常量不可变

<li>
  void function(char* const Var);   //参数指针本身为常量不可变(也无意义，var本身也是通过传值的形式赋值的)

<li>
  void function(const Class&amp; Var); //引用参数在函数内不可以改变

</ul>
<li>
  参数const通常用于参数为指针或引用的情况，若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。

</ul>

<h3 id="toc_0.1.3">const修饰成员函数的返回值 </h3>
<p>
1、一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回const对象，或返回const对象的引用，则返回值具有const属性，返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。
2、如果给采用“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针所指的内容）不能被修改，该返回值只能被赋给加const 修饰的同类型指针。
3、函数返回值采用“引用传递”的场合不多，这种方式一般只出现在类的赙值函数中，目的是为了实现链式表达。
</p>
   

<h2 id="toc_0.2">volatile</h2>
<ul>
<li>
  It can be used in the same places that const can be used. volatile can be thought of as almost the opposite of const : 

<li>
  It marks something that can be modified at any time, perhaps by another program or another thread. 

<li>
  It is a hint to the compiler that there should be no optimization during access to it.

<li>
  It can be used for variables, but more commonly, it is used for pointers. Like const , it can be applied to the pointer or the addressed memory. 
<pre>
        To declare a regular pointer to volatile memory, use this form:
            volatile char* vcharptr;
        To declare a volatile pointer to regular memory, use this form:
            char* volatile vptrchar;
</pre>

</ul>
    
<ul>
<li>
  volatile的本意是“易变的”

<ul>
<li>
  volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件或者其它线程等。

<li>
  遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。 

<li>
  当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被寄存。 

</ul>
</ul>

<h2 id="toc_0.3">mutable</h2>
<ul>
<li>
  mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。

<li>
  在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量(mutable只能由于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。 
<pre>
        class ClxTest
        {
        public:
        　　ClxTest();
        　　~ClxTest();
        　　void Output() const;
        private:
        　　mutable int m_iTimes;
        };

        ClxTest::ClxTest()
        {
            m_iTimes = 0;
        }

        ClxTest::~ClxTest()
        {}

        void ClxTest::Output() const
        {
            cout &lt;&lt; "Output for test!" &lt;&lt; endl;
            m_iTimes++;
        } 
</pre>

</ul>


   <hr />
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'rickhuang'; // required: replace example with your forum shortname

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</body>
</html>
