<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Ա</title>
    <link rel="stylesheet" type="text/css" href="css/shCoreDefault.css"/>
    <link rel="Stylesheet" type="text/css" href="static/css/wiki.css">
    <link rel="Stylesheet" type="text/css" href="static/bootstrap/css/bootstrap.min.css">
    <script type="text/javascript" src="static/js/jquery.min.js"></script>
    <script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/js/wiki.js"></script>
    <script type="text/javascript" src="static/js/shCore.js"></script>
    <script type="text/javascript" src="static/js/shBrushPython.js"></script>
    <script type="text/javascript" src="static/js/shBrushCpp.js"></script>
    <script type="text/javascript" src="static/js/shBrushErlang.js"></script>
    <script type="text/javascript" src="static/js/shBrushBash.js"></script>
    <script type="text/javascript" src="static/js/shBrushRuby.js"></script>
    <script type="text/javascript" src="static/js/shBrushSql.js"></script>
    <script type="text/javascript" src="static/js/shBrushJScript.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<nav class="navbar navbar-default navbar-inverse" role="navigation">
 <div class="container">
    <div class="navbar-header">
<button data-target=".bs-navbar-collapse" data-toggle="collapse" type="button" class="navbar-toggle">
	<span class="sr-only"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
      </button>
	<a class="navbar-brand" href="main.html">Rick's wiki</a>
    </div>
    <div class="collapse navbar-collapse">
	<ul class="nav navbar-nav">
	    <li><a href="main.html">Home</a></li>
	    <li><a href="TODO.html">TODO</a></li>
	</ul>
    </div>
 </div>
</nav>
<div class="container content-body">
    
<div class="toc">
<ul>
<li><a href="#toc_0.1">12 系统调用与API</a>
<ul>
<li><a href="#toc_0.1.1">Linux系统调用</a>
<li><a href="#toc_0.1.2">运行库 </a>
</ul>
<li><a href="#toc_0.2">进程地址空间分布</a>
<ul>
<li><a href="#toc_0.2.1">栈 </a>
<li><a href="#toc_0.2.2">堆 </a>
</ul>
<li><a href="#toc_0.3">系统调用</a>
<li><a href="#toc_0.4">C运行库 </a>
</ul>
</ul>
</div>

<h2 id="toc_0.1">12 系统调用与API</h2>
<ul>
<li>
  系统调用是应用程序（运行库也是应用程序的一部分）与操作系统内核之间的接口， 它决定了应用程序是如何与内核打交道的。

<li>
  Windows系统是完全基于DLL机制的， 它通过DLL对系统调用进行了包装， 形成了所谓的Windows API。 

<li>
  Linux使用0x80号中断作为系统调用的入口

<li>
  Windows使用0x2E号中断作为系统调用的入口

</ul>

<h3 id="toc_0.1.1">Linux系统调用</h3>
<ul>
<li>
  x86下，系统调用由0x80中断完成

<li>
  各个通用寄存器用于传递参数， EAX寄存器用于表示系统调用的接口号， EAX=1表示退出进程(exit), EAX=2表示创建进程(fork)...

<li>
  每个系统调用都对应于内核源代码中的一个函数， 它们都以sys_开头， 如sys_exit

<li>
  当系统调用返回时， EAX作为调用结果的返回值

</ul>

<h3 id="toc_0.1.2">运行库 </h3>
<ul>
<li>
  运行时库将不同的操作系统的系统调用包装为统一固定的接口， 使得同样的代码， 在不同的都可以直接编译， 并产生一致的效果， 实现源代码级的可移植性

<li>
  运行库是保证多个平台之间能够通用， 它是取各个平台之间功能的交集

<li>
  Windows原生支持图形和用户交互系统， Linux不是原生支持， 所以运行库就不包含这个功能

</ul>


<h2 id="toc_0.2">进程地址空间分布</h2>
<ul>
<li>
  32位系统中， 内存空间拥有4GB的寻址能力， 其中1GB空间分配给内核， 3GB作为用户空间
<pre>
    Kernel Space            0xffffffff

    stack                   0xc0000000                  栈顶

    unused

    dynamic libraries       0x40000000                  在2.6之后内核， 动态库加载地址变成靠近栈的位置0xbfxxxxxx处，
                                                        这样堆的可用空间变大了!!!   在/proc/xxx/maps中查看
    unused

    heap                    

    read/write sections(.data .bss)
    readonly sections(.init .rodata)    0x08048000      程序映像加载地址

    reserved                0
</pre>

<li>
  如果可执行文件依赖其他共享库， 系统在0x40000000开始的地址分配相应的空间， 并将共享库载入到该空间

</ul>

<h3 id="toc_0.2.1">栈 </h3>
<ul>
<li>
  调用惯例

<ul>
<li>
  函数参数的传递顺序和方式

<li>
  栈的维护方式

<li>
  名字修饰策略        不同的调用惯例有不同的名字修饰策略

</ul>
<li>
  C语言中存在多个调用惯例， 默认的是cdecl
<pre>
    调用惯例    参数传递        出栈方                          名字修饰
    cdecl       函数调用方      从右至左顺序压栈                下划线+函数名
    stdcall     函数本身        从右至左顺序压栈                下划线+函数名+参数的字节数
    fastcall    函数本身        头两个放入寄存器， 其它压栈     @函数名+@+参数字节数
    pascal      函数本身        从左至右顺序压栈                较为复杂
</pre>

<li>
  函数栈布局
<pre>
    int _cdecl foo(int n, int m)

                m                                      
    ebp+12      
                n                       在调用函数中执行， 先压栈参数， 然后将返回地址压栈， 由call完成                       
    ebp+8
                返回地址
    ebp+4
    --------------------------------
                old ebp
    ebp         

                保存寄存器和局部变量    在被调用函数中执行， 函数入口处， 先将ebp压栈， 再将寄存器压栈， 最后分配栈局部变量
                                        函数在退出前， 执行相反的动作， 弹出寄存器， 再弹出ebp， 由ret完成
    esp
    
    ================================
    ebp     指向old ebp
    ebp+4   指向n
</pre>

</ul>

<h3 id="toc_0.2.2">堆 </h3>
<ul>
<li>
  malloc  程序向操作系统申请一块适当大小的堆空间， 然后由程序自己管理， 实际是由运行库来管理的

<li>
  Linux下堆分配方式有两种， 即两个系统调用：  brk()和mmap()

<ul>
<li>
  brk     设置进程数据段的结束地址

<li>
  mmap    与Windows下的VirtualAlloc相似， 向操作系统申请一段虚拟地址空间。 当不将地址空间映射到某个文件时， 可当作堆空间(匿名空间)

<li>
  glibc中malloc的实现：   小于128KB的请求， 在现有堆空间按堆分配算法分配一块空间返回；大于128KB， 使用mmap分配一块匿名空间

</ul>
<li>
  Windows堆管理器：   HeapCreate、HeapAlloc、HeapFree、HeapDesctroy

<ul>
<li>
  MSVC的malloc函数调用了HeapAlloc这个API， 将堆管理的过程交给操作系统， 在入口函数中， 调用了HeapCreate。

<li>
  NTDLL.DLL   这个dll是windows OS用户层最底层的DLL， 它负责Windows子系统dll与Windows内核之间的接口， 用户程序、运行时库和子系统的堆分配使用它

<li>
  Ntoskrnl.exe    它负责Windows内核中的堆空间分配， 内核、内核组件、驱动程序使用堆时用它提供的功能， 接口以RtlHeap开头

</ul>
<li>
  堆分配算法

<ul>
<li>
  空闲链表

<li>
  位图

<li>
  对象池

</ul>
</ul>


<h2 id="toc_0.3">系统调用</h2>
<ul>
<li>
  linux使用0x80作为系统调用的中断向量号， 但是效率不高， 在2.5版之后使用新的机制， Intel奔腾处理器之后提供专用系统调用指令：sysenter和sysexit

<ul>
<li>
  linux-gate.so.1用于支持新型系统调用的"虚拟"共享库， 使用ldd /bin/ls看到它不对应任何文件， 它总被加载在0xffffe000的位置上 

</ul>
<li>
  Windows使用0x2E作为系统调用入口

</ul>

<h2 id="toc_0.4">C运行库 </h2>
<ul>
<li>
  GNU:    
<pre>
    glibc是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。
    glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。
</pre>

</ul>

<ul>
<li>
  Windows:  
<pre>
    VC++完美的支持C和C++标准，因此也就按照C和C++的标准定义的函数原型实现了上述运行时库。
　　对于C运行时库CRT，VC6.0、VC2005、VC2008和VC2010均提供了DLL版本和LIB版本。
    
    C:
    上述各个编译器提供的LIB版的CRT库，均实现在libcmt.lib。对应的调试版名称为libcmtd.lib。

　　而DLL版本名称根据编译器不同而不同，我们可以从名称上加以分辨。
　　VC6.使用的CRT库的DLL版本在MSVCRT.DLL中实现， 对应调试版本为MSVCRTD.LIB。
　　VC2005使用的CRT库的DLL版本在MSVCR80.DLL中实现，对应调试版本为MSVCR80.DLL。
　　VC2008使用的CRT库的DLL版本在MSVCR90.DLL中实现，对应调试版本为MSVCR90D.DLL。
　　VC2010使用的CRT库的DLL版本在MSVCR100.DLL中实现，对应调试版本为MSVCR100D.DLL。

    C++:
　　C++标准兼容C标准，但VC各版本将C++编译器使用的C标准库与C编译器使用的C运行库一起实现，它们使用相同的运行库。

　　对于C++标准库中的IO流和STL，VC6.0、VC2005、VC2008和VC2010也提供了DLL版本和LIB版本。
　　LIB版均实现在libcpmt.lib中，对应的调试版本为libcpmtd.lib。

　　不同版本的编译器实现的DLL也不相同。
　　VC6.使用的C++类库的 DLL版本在MSVCP60.DLL中实现， 对应调试版本为MSVCP60D.LIB。
　　VC2005使用的C++类库的DLL版本在MSVCP80.DLL中实现，对应调试版本为MSVCP80.DLL。
　　VC2008使用的C++类库的 DLL版本在MSVCP90.DLL中实现，对应调试版本为MSVCP90D.DLL。
　　VC2010使用的C++类库的DLL版本在MSVCP100.DLL中实现，对应调试版本为MSVCP100D.DLL。


    配置选项来设置程序使用的C和C++运行时库的类型:
    MT选项：链接LIB版的C和C++运行库。在链接时就会在将C和C++运行时库集成到程序中成为程序中的代码，程序体积会变大。
　　MTd选项：LIB的调试版。
　　MD选项：使用DLL版的C和C++运行库，这样在程序运行时会动态的加载对应的DLL，程序体积会减小，缺点是在系统没有对应DLL时程序无法运行。
　　MDd选项：表示使用DLL的调试版。
</pre>

</ul>


   <hr />
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'rickhuang'; // required: replace example with your forum shortname

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</body>
</html>
