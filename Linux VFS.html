<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=cp936">
    <title>Linux VFS</title>
    <link rel="stylesheet" type="text/css" href="css/shCoreDefault.css"/>
    <link rel="Stylesheet" type="text/css" href="static/css/wiki.css">
    <link rel="Stylesheet" type="text/css" href="static/bootstrap/css/bootstrap.min.css">
    <script type="text/javascript" src="static/js/jquery.min.js"></script>
    <script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/js/wiki.js"></script>
    <script type="text/javascript" src="static/js/shCore.js"></script>
    <script type="text/javascript" src="static/js/shBrushPython.js"></script>
    <script type="text/javascript" src="static/js/shBrushCpp.js"></script>
    <script type="text/javascript" src="static/js/shBrushErlang.js"></script>
    <script type="text/javascript" src="static/js/shBrushBash.js"></script>
    <script type="text/javascript" src="static/js/shBrushRuby.js"></script>
    <script type="text/javascript" src="static/js/shBrushSql.js"></script>
    <script type="text/javascript" src="static/js/shBrushJScript.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<nav class="navbar navbar-default navbar-inverse" role="navigation">
 <div class="container">
    <div class="navbar-header">
<button data-target=".bs-navbar-collapse" data-toggle="collapse" type="button" class="navbar-toggle">
	<span class="sr-only"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
      </button>
	<a class="navbar-brand" href="main.html">Rick's wiki</a>
    </div>
    <div class="collapse navbar-collapse">
	<ul class="nav navbar-nav">
	    <li><a href="main.html">Home</a></li>
	    <li><a href="TODO.html">TODO</a></li>
	</ul>
    </div>
 </div>
</nav>
<div class="container content-body">
    
<div class="toc">
<ul>
<li><a href="#toc_1">通用文件模型</a>
<ul>
<li><a href="#toc_1.1">inode</a>
<li><a href="#toc_1.2">链接</a>
<li><a href="#toc_1.3">编程接口</a>
</ul>
<li><a href="#toc_2">VFS结构</a>
<ul>
<li><a href="#toc_2.1">inode</a>
<li><a href="#toc_2.2">特定于进程的信息</a>
<li><a href="#toc_2.3">目录项缓存 </a>
</ul>
<li><a href="#toc_3">VFS对象操作</a>
<ul>
<li><a href="#toc_3.1">文件系统操作</a>
<li><a href="#toc_3.2">文件操作</a>
</ul>
</ul>
</div>

<p>
VFS (Virtual File System)
为支持各种本机文件系统， 且在同时允许访问其他操作系统的文件， Linux内核在用户空间(或C标准库)和文件系统实现之间引入了一个抽象层， 该抽象层称之为虚拟文件系统
VFS不仅为文件系统提供了方法和抽象， 还支持文件系统中对象(或文件)的统一视图
VFS是一个胶水层， 位于内核的底层和用户层之间。 它提供了各种抽象数据结构来表示文件和inode， 而真实文件系统的实现必须填充这些结构， 使得应用程序无需考虑底层文件系统， 总是可以使用同样的接口访问和操作文件。
</p>

<p>
文件系统类型：
</p>
<ul>
<li>
  基于磁盘的文件系统

<li>
  虚拟文件系统

<li>
  网络文件系统

</ul>

<h1 id="toc_1">通用文件模型</h1>
<p>
VFS提供了一种结构模型， 包含了一个强大文件系统所应具备的所有组件。但该模型只存在于虚拟中， 必须使用各种对象和函数指针与每种文件系统适配。
所有文件系统的实现都必须提供与VFS定义的结构配合的例程， 以弥合两种视图之间的差异！！！
</p>

<p>
在处理文件时， 内核与用户空间使用的主要对象是不同的。
</p>
<ul>
<li>
  对用户来说， 一个文件由一个文件描述符标识， 该描述符是一个整数， 是在打开文件时由内核分配阀， 只在一个进程内部有效， 所有文件操作都用它来标识文件

<li>
  内核处理文件的关键是inode， 每个文件（或目录）都有且只有一个对应的inode， 其中包含元数据(如访问上隉、上次修改时间等)和指向文件数据指针， 但不包括文件名

</ul>

<h2 id="toc_1.1">inode</h2>
<p>
inodes用来构成文件系统的目录层次结构， inode成员分为两类：
</p>
<ul>
<li>
  描述文件状态的元数据

<li>
  保存实际文件内容的指针

</ul>

<p>
目录是特殊的文件， 它的数据段不包含普通数据， 而是目录项， 每个目录项由两个成员组成：
</p>
<ul>
<li>
  该目录项的数据所在inode的编号

<li>
  文件或目录的名称

</ul>
<p>
系统中所有的inode都有一个特定的编号， 用于唯一地标识各个inode. 文件与inode之间的关联即通过该编号建立.
</p>

<h2 id="toc_1.2">链接</h2>
<ul>
<li>
  符号链接    -&gt; 对每个符号链接都使用一个独立的inode， 该inode的数据段包含一个字符吕， 给出了连接目标的路径

<li>
  硬链接      -&gt; ？？？

</ul>
 
<h2 id="toc_1.3">编程接口</h2>
<p>
用户进程和内核的VFS实现之间接口照例由系统调用组成， 其中大数涉及对文件、目录和一般意义上的文件系统的操作
</p>

<h1 id="toc_2">VFS结构</h1>
<p>
VFS由两部分组成：   文件和文件系统
VFS在对底层文件系统的访问时， 没有使用固定的函数， 而是使用了函数指针。
这引动函数指针保存在两个结构中， 包括了所有的相关的函数：
1)  inode操作(i_op)： 创建链接、文件重命名、在目录中生成新文件、删除文件
2)  文件操作(i_fop)： 作用于文件的数据内容。 它们包含一些显示的操作(读和写), 还包括如设置文件位置指针和创建内存映射之类的操作
</p>

<h2 id="toc_2.1">inode</h2>
<ul>
<li>
  &lt;fs.h&gt;  struct inode

<li>
  inode结构存在于内存中， 因而包含一些实际介质上存储的inode所没有的成员。这些是由内核自身在从底层文件系统读入信息时生成或动态建立的。

<li>
  还有一些文件系统， 并没有使用经典意义上的inode， 因此必须从其包含的数据中提取信息并生成这里给出的形式。

<li>
  当inode表示设备文件时， 成员i_rdev表示设备， 通过它能找到对应的设备实例。 匿名联合包含了指向设备专用数据结构的指针

<li>
  对inode的操作包含在两个函数数组指针中， i_op和i_fop

<li>
  inode链表

<ul>
<li>
  每个inode都有一个i_list成员， 可以将inode存储在一个链表中， 根据inode状态， 它可能有3种主要的情况

<ul>
<li>
  inode存在于内存中， 未关联到任何文件， 也不处于活动使用状态

<li>
  inode存在内存中， 正在由一个或多个进程使用， 通常表示一个文件

<li>
  inode处于活动使用状态， 其数据内容已经改变， 与存储介质上的内容不同， 称为脏的inode

</ul>
<li>
  fs/inode.c中内核定义了两个全局变量用作表头， inode_unused用于有效但非活动的i_node(第一类)， inode_in_use用于所有使用但未改变的inode(第二类), 脏的inode保存在超级块的链表中。

</ul>
<li>
  inode不仅出现在特定的链表中， 还在一个散列中， 以支持根据inode编号和超级块快速访问inode，该散列表是一个数组， 在fs/inode.c中的inode_init函数初始化

</ul>

<h2 id="toc_2.2">特定于进程的信息</h2>
<ul>
<li>
  文件描述符用于在一个进程内唯一标识打开的文件, 它是struct file数组的索引

<li>
  进程的task_struct结构中与文件相关的成员， fs(文件系统相关数据), files(包含当前进程的各个文件描述符)

<li>
  task_struct-&gt;struct files_struct files-&gt;struct file(该结构中包含内核看到的文件的特征信息) -&gt; struct path(提供了文件名与inode之间的关联)

<li>
  task_struct-&gt;struct fs_struct   特定于进程的数据， 文件权限、进程根目录、文件系统等信息

</ul>

<h2 id="toc_2.3">目录项缓存 </h2>
<ul>
<li>
  struct dentry   该结构的主要用途是建立文件名与相关的inode之间的关联

<li>
  在VFS连同文件系统实现读取的一个目录项(目录或文件)的数据之后， 则创建一个dentry实例， 以缓存找到的数据

<li>
  每个由VFS发送到底层实现的请求， 都会导致创建一个新的dentry对象， 以保存请求的结果。这些对象保存在一个缓存中， 在下一次需要时可以更快速的访问。

<li>
  缓存如何组织， 包含两部分：

<ul>
<li>
  一个散列表(dentry_hashtable)包含了所有的dentry对象

<li>
  一个LRU(最近最少使用， last rencently used)链表， 其中不再使用的对象将授予一个最后宽限期， 宽限期过后才从内存移除

</ul>
<li>
  dentry_operations结构保存了指向各种特定于文件系统可以对dentry对象执行的操作的函数指针

</ul>

<h1 id="toc_3">VFS对象操作</h1>
<h2 id="toc_3.1">文件系统操作</h2>
<ul>
<li>
  注册文件系统    fs/super.c中的register_filesystem用来向内核注册文件系统

<ul>
<li>
  struct file_system_type     描述文件系统类型的结构

<li>
  每个装载的文件系统， 在内在中都创建一个超级块结构， 该结构保存了文件系统它本身和装载点的有关信息

<li>
  同一文件系统类型可能对应多个超级块结构， 这些超级块聚焦在一个单向链表中， file_system_type-&gt;fs_supers是表头

</ul>
<li>
  装载和卸载

<ul>
<li>
  struct vfsmount     每个装载的文件系统都对应一个vfsmount结构的实例

<li>
  struct super_block  每个文件系统都有且仅有一个超级块实例， struct super_operations包含对超级块操作的函数指针, 操作的实现由底层文件系统提供。

</ul>
</ul>

<h2 id="toc_3.2">文件操作</h2>
<ul>
<li>
  VFS以各种系统调用的形式提供用于文件处理的接口函数

<li>
  fs/namei.c          path_look()     内核使用该函数查找路径或文件名， nameidata用于保存查找结果

<li>
  fs/open.c           sys_open()      打开文件

<li>
  fs/read_write.c     sys_read(), sys_write()   读取与写入

</ul>


   <hr />
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'rickhuang'; // required: replace example with your forum shortname

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</body>
</html>
