<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=cp936">
    <title>NTProcessInfo.cpp</title>
    <link rel="stylesheet" type="text/css" href="css/shCoreDefault.css"/>
    <link rel="Stylesheet" type="text/css" href="static/css/wiki.css">
    <link rel="Stylesheet" type="text/css" href="static/bootstrap/css/bootstrap.min.css">
    <script type="text/javascript" src="static/js/jquery.min.js"></script>
    <script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/js/wiki.js"></script>
    <script type="text/javascript" src="static/js/shCore.js"></script>
    <script type="text/javascript" src="static/js/shBrushPython.js"></script>
    <script type="text/javascript" src="static/js/shBrushCpp.js"></script>
    <script type="text/javascript" src="static/js/shBrushErlang.js"></script>
    <script type="text/javascript" src="static/js/shBrushBash.js"></script>
    <script type="text/javascript" src="static/js/shBrushRuby.js"></script>
    <script type="text/javascript" src="static/js/shBrushSql.js"></script>
    <script type="text/javascript" src="static/js/shBrushJScript.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<nav class="navbar navbar-default navbar-inverse" role="navigation">
 <div class="container">
    <div class="navbar-header">
<button data-target=".bs-navbar-collapse" data-toggle="collapse" type="button" class="navbar-toggle">
	<span class="sr-only"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
      </button>
	<a class="navbar-brand" href="main.html">Rick's wiki</a>
    </div>
    <div class="collapse navbar-collapse">
	<ul class="nav navbar-nav">
	    <li><a href="main.html">Home</a></li>
	    <li><a href="TODO.html">TODO</a></li>
	</ul>
    </div>
 </div>
</nav>
<div class="container content-body">
    
<pre>
    //***********************************************************************/
    // Functions to access NtQueryInformationProcess in NTDLL.DLL
    //
    // Copyright ?2007 Steven Moore (OrionScorpion).  All Rights Reserved.
    //
    //***********************************************************************/
    #include "stdafx.h"
    #include "NTProcessInfo.h"

    // Enable a privilege for a process token
    // The privilege must already be assigned
    // This function only enables not assigns
    BOOL sm_EnableTokenPrivilege(LPCTSTR pszPrivilege)
    {
        HANDLE hToken		 = 0;
        TOKEN_PRIVILEGES tkp = {0}; 

        // Get a token for this process. 
        if (!OpenProcessToken(GetCurrentProcess(),
                              TOKEN_ADJUST_PRIVILEGES |
                              TOKEN_QUERY, &amp;hToken))
        {
            return FALSE;
        }

        // Get the LUID for the privilege. 
        if(LookupPrivilegeValue(NULL, pszPrivilege,
                                &amp;tkp.Privileges[0].Luid)) 
        {
            tkp.PrivilegeCount = 1;  // one privilege to set    
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Set the privilege for this process. 
            AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, 0,
                                  (PTOKEN_PRIVILEGES)NULL, 0); 

            if (GetLastError() != ERROR_SUCCESS)
                return FALSE;
            
            return TRUE;
        }

        return FALSE;
    }

    pfnNtQueryInformationProcess gNtQueryInformationProcess;
    // Load NTDLL Library and get entry address
    // for NtQueryInformationProcess
    HMODULE sm_LoadNTDLLFunctions()
    {
        HMODULE hNtDll = LoadLibrary(_T("ntdll.dll"));
        if(hNtDll == NULL) return NULL;

        gNtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(hNtDll,
                                                            "NtQueryInformationProcess");
        if(gNtQueryInformationProcess == NULL) {
            FreeLibrary(hNtDll);
            return NULL;
        }
        return hNtDll;
    }

    // Unloads the NTDLL.DLL and resets the
    // global gNtQueryInformationProcess variable
    void sm_FreeNTDLLFunctions(HMODULE hNtDll)
    {
        if(hNtDll)
            FreeLibrary(hNtDll);
        gNtQueryInformationProcess = NULL;
    }

    // Gets information on process with NtQueryInformationProcess
    BOOL sm_GetNtProcessInfo(const DWORD dwPID, smPROCESSINFO *ppi)
    {
        BOOL  bReturnStatus						= TRUE;
        DWORD dwSize							= 0;
        DWORD dwSizeNeeded						= 0;
        SIZE_T dwBytesRead						= 0;
        DWORD dwBufferSize						= 0;
        HANDLE hHeap							= 0;
        WCHAR *pwszBuffer						= NULL;

        smPROCESSINFO spi						= {0};
        smPPROCESS_BASIC_INFORMATION pbi		= NULL;

        smPEB peb								= {0};
        smPEB_LDR_DATA peb_ldr					= {0};
        smRTL_USER_PROCESS_PARAMETERS peb_upp	= {0};

        ZeroMemory(&amp;spi, sizeof(spi));
        ZeroMemory(&amp;peb, sizeof(peb));
        ZeroMemory(&amp;peb_ldr, sizeof(peb_ldr));
        ZeroMemory(&amp;peb_upp, sizeof(peb_upp));

        spi.dwPID = dwPID;

        // Attempt to access process
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | 
                                      PROCESS_VM_READ, FALSE, dwPID);
        if(hProcess == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        // Try to allocate buffer 
        hHeap = GetProcessHeap();

        dwSize = sizeof(smPROCESS_BASIC_INFORMATION);

        pbi = (smPPROCESS_BASIC_INFORMATION)HeapAlloc(hHeap,
                                                      HEAP_ZERO_MEMORY,
                                                      dwSize);
        // Did we successfully allocate memory
        if(!pbi) {
            CloseHandle(hProcess);
            return FALSE;
        }

        // Attempt to get basic info on process
        NTSTATUS dwStatus = gNtQueryInformationProcess(hProcess,
                                                      ProcessBasicInformation,
                                                      pbi,
                                                      dwSize,
                                                      &amp;dwSizeNeeded);

        // If we had error and buffer was too small, try again
        // with larger buffer size (dwSizeNeeded)
        if(dwStatus &gt;= 0 &amp;&amp; dwSize &lt; dwSizeNeeded)
        {
            if(pbi)
                HeapFree(hHeap, 0, pbi);
            pbi = (smPPROCESS_BASIC_INFORMATION)HeapAlloc(hHeap,
                                                          HEAP_ZERO_MEMORY,
                                                          dwSizeNeeded);
            if(!pbi) {
                CloseHandle(hProcess);
                return FALSE;
            }

            dwStatus = gNtQueryInformationProcess(hProcess,
                                                 ProcessBasicInformation,
                                                 pbi, dwSizeNeeded, &amp;dwSizeNeeded);
        }

        // Did we successfully get basic info on process
        if(dwStatus &gt;= 0)
        {
            // Basic Info
    //        spi.dwPID			 = (DWORD)pbi-&gt;UniqueProcessId;
            spi.dwParentPID		 = (DWORD)pbi-&gt;InheritedFromUniqueProcessId;
            spi.dwBasePriority	 = (LONG)pbi-&gt;BasePriority;
            spi.dwExitStatus	 = (NTSTATUS)pbi-&gt;ExitStatus;
            spi.dwPEBBaseAddress = (DWORD)pbi-&gt;PebBaseAddress;
            spi.dwAffinityMask	 = (DWORD)pbi-&gt;AffinityMask;

            // Read Process Environment Block (PEB)
            if(pbi-&gt;PebBaseAddress)
            {
                if(ReadProcessMemory(hProcess, pbi-&gt;PebBaseAddress, &amp;peb, sizeof(peb), &amp;dwBytesRead))
                {
                    spi.dwSessionID	   = (DWORD)peb.SessionId;
                    spi.cBeingDebugged = (BYTE)peb.BeingDebugged;

                    // Here we could access PEB_LDR_DATA, i.e., module list for process
    //				dwBytesRead = 0;
    //				if(ReadProcessMemory(hProcess,
    //									 pbi-&gt;PebBaseAddress-&gt;Ldr,
    //									 &amp;peb_ldr,
    //									 sizeof(peb_ldr),
    //									 &amp;dwBytesRead))
    //				{
                        // get ldr
    //				}

                    // if PEB read, try to read Process Parameters
                    dwBytesRead = 0;
                    if(ReadProcessMemory(hProcess,
                                         peb.ProcessParameters,
                                         &amp;peb_upp,
                                         sizeof(smRTL_USER_PROCESS_PARAMETERS),
                                         &amp;dwBytesRead))
                    {
                        // We got Process Parameters, is CommandLine filled in
                        if(peb_upp.CommandLine.Length &gt; 0) {
                            // Yes, try to read CommandLine
                            pwszBuffer = (WCHAR *)HeapAlloc(hHeap,
                                                            HEAP_ZERO_MEMORY,
                                                            peb_upp.CommandLine.Length);
                            // If memory was allocated, continue
                            if(pwszBuffer)
                            {
                                if(ReadProcessMemory(hProcess,
                                                     peb_upp.CommandLine.Buffer,
                                                     pwszBuffer,
                                                     peb_upp.CommandLine.Length,
                                                     &amp;dwBytesRead))
                                {
                                    // if commandline is larger than our variable, truncate
                                    if(peb_upp.CommandLine.Length &gt;= sizeof(spi.szCmdLine)) 
                                        dwBufferSize = sizeof(spi.szCmdLine) - sizeof(TCHAR);
                                    else
                                        dwBufferSize = peb_upp.CommandLine.Length;
                                
                                    // Copy CommandLine to our structure variable
                #if defined(UNICODE) || (_UNICODE)
                                    // Since core NT functions operate in Unicode
                                    // there is no conversion if application is
                                    // compiled for Unicode
                                    StringCbCopyN(spi.szCmdLine, sizeof(spi.szCmdLine),
                                                  pwszBuffer, dwBufferSize);
                #else
                                    // Since core NT functions operate in Unicode
                                    // we must convert to Ansi since our application
                                    // is not compiled for Unicode
                                    WideCharToMultiByte(CP_ACP, 0, pwszBuffer,
                                                        (int)(dwBufferSize / sizeof(WCHAR)),
                                                        spi.szCmdLine, sizeof(spi.szCmdLine),
                                                        NULL, NULL);
                #endif
                                }
                                if(!HeapFree(hHeap, 0, pwszBuffer)) {
                                    // failed to free memory
                                    bReturnStatus = FALSE;
                                    goto gnpiFreeMemFailed;
                                }
                            }
                        }	// Read CommandLine in Process Parameters

                        // We got Process Parameters, is ImagePath filled in
                        if(peb_upp.ImagePathName.Length &gt; 0) {
                            // Yes, try to read ImagePath
                            dwBytesRead = 0;
                            pwszBuffer = (WCHAR *)HeapAlloc(hHeap,
                                                            HEAP_ZERO_MEMORY,
                                                            peb_upp.ImagePathName.Length);
                            if(pwszBuffer)
                            {
                                if(ReadProcessMemory(hProcess,
                                                     peb_upp.ImagePathName.Buffer,
                                                     pwszBuffer,
                                                     peb_upp.ImagePathName.Length,
                                                     &amp;dwBytesRead))
                                {
                                    // if ImagePath is larger than our variable, truncate
                                    if(peb_upp.ImagePathName.Length &gt;= sizeof(spi.szImgPath)) 
                                        dwBufferSize = sizeof(spi.szImgPath) - sizeof(TCHAR);
                                    else
                                        dwBufferSize = peb_upp.ImagePathName.Length;

                                    // Copy ImagePath to our structure
                #if defined(UNICODE) || (_UNICODE)
                                    StringCbCopyN(spi.szImgPath, sizeof(spi.szImgPath),
                                                  pwszBuffer, dwBufferSize);
                #else
                                    WideCharToMultiByte(CP_ACP, 0, pwszBuffer,
                                                        (int)(dwBufferSize / sizeof(WCHAR)),
                                                        spi.szImgPath, sizeof(spi.szImgPath),
                                                        NULL, NULL);
                #endif
                                }
                                if(!HeapFree(hHeap, 0, pwszBuffer)) {
                                    // failed to free memory
                                    bReturnStatus = FALSE;
                                    goto gnpiFreeMemFailed;
                                }
                            }
                        }	// Read ImagePath in Process Parameters
                    }	// Read Process Parameters
                }	// Read PEB 
            }	// Check for PEB

            // System process for WinXP and later is PID 4 and we cannot access
            // PEB, but we know it is aka ntoskrnl.exe so we will manually define it.
            // ntkrnlpa.exe if Physical Address Extension (PAE)
            // ntkrnlmp.exe if Symmetric MultiProcessing (SMP)
            // Actual filename is ntoskrnl.exe, but other name will be in
            // Original Filename field of version block.
            if(spi.dwPID == 4) {
                ExpandEnvironmentStrings(_T("%SystemRoot%\\System32\\ntoskrnl.exe"),
                                         spi.szImgPath, sizeof(spi.szImgPath));
            }
        }	// Read Basic Info

    gnpiFreeMemFailed:

        // Free memory if allocated
        if(pbi != NULL)
            if(!HeapFree(hHeap, 0, pbi)) {
                // failed to free memory
            }

        CloseHandle(hProcess);

        // Return filled in structure to caller
        *ppi = spi;

        return bReturnStatus;
    }

    BOOL GetNtProcessInfoViaPid(DWORD dwPID, smPROCESSINFO *ppi)
    {
        BOOL bRet = FALSE;
        //== only to have better chance to read processes =====
        if(!sm_EnableTokenPrivilege(SE_DEBUG_NAME)) 
        {
            //BTDEVMGR_DBG((_T("sm_EnableTokenPrivilege fail")));
            //return bRet;
        }


        HMODULE hNtDll = sm_LoadNTDLLFunctions();

        if(hNtDll)
        {
            if(sm_GetNtProcessInfo(dwPID, ppi))
            {
                // Do something else upon success
                bRet = TRUE;
            }
            else
            {
                //BTDEVMGR_DBG((_T("sm_GetNtProcessInfo fail")));

            }
            sm_FreeNTDLLFunctions(hNtDll);	
        }
        else
        {
            //BTDEVMGR_DBG((_T("sm_LoadNTDLLFunctions fail")));
        }


        return bRet;
    }
</pre>


   <hr />
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'rickhuang'; // required: replace example with your forum shortname

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</body>
</html>
