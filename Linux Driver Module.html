<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=cp936">
    <title>Linux Driver Module</title>
    <link rel="stylesheet" type="text/css" href="css/shCoreDefault.css"/>
    <link rel="Stylesheet" type="text/css" href="static/css/wiki.css">
    <link rel="Stylesheet" type="text/css" href="static/bootstrap/css/bootstrap.min.css">
    <script type="text/javascript" src="static/js/jquery.min.js"></script>
    <script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/js/wiki.js"></script>
    <script type="text/javascript" src="static/js/shCore.js"></script>
    <script type="text/javascript" src="static/js/shBrushPython.js"></script>
    <script type="text/javascript" src="static/js/shBrushCpp.js"></script>
    <script type="text/javascript" src="static/js/shBrushErlang.js"></script>
    <script type="text/javascript" src="static/js/shBrushBash.js"></script>
    <script type="text/javascript" src="static/js/shBrushRuby.js"></script>
    <script type="text/javascript" src="static/js/shBrushSql.js"></script>
    <script type="text/javascript" src="static/js/shBrushJScript.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<nav class="navbar navbar-default navbar-inverse" role="navigation">
 <div class="container">
    <div class="navbar-header">
<button data-target=".bs-navbar-collapse" data-toggle="collapse" type="button" class="navbar-toggle">
	<span class="sr-only"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
      </button>
	<a class="navbar-brand" href="main.html">Rick's wiki</a>
    </div>
    <div class="collapse navbar-collapse">
	<ul class="nav navbar-nav">
	    <li><a href="main.html">Home</a></li>
	    <li><a href="TODO.html">TODO</a></li>
	</ul>
    </div>
 </div>
</nav>
<div class="container content-body">
    
<div class="toc">
<ul>
<li><a href="#toc_1">kobject， kset， subsystem</a>
<ul>
<li><a href="#toc_1.1">kobject</a>
<li><a href="#toc_1.2">kset</a>
<li><a href="#toc_1.3">子系统 </a>
<li><a href="#toc_1.4">热插拔事件 </a>
</ul>
<li><a href="#toc_2">Linux设备模型的上层容器 </a>
<ul>
<li><a href="#toc_2.1">Bus</a>
<li><a href="#toc_2.2">Device</a>
<li><a href="#toc_2.3">Device Driver</a>
<li><a href="#toc_2.4">Class</a>
</ul>
</ul>
</div>

<p>
Linux设备模型：
建立模型的意义在于文件管理设备。 Linux设备模型包含如下功能：
</p>
<ol>
<li>
  电源管理与系统关机

<li>
  与用户空间通信， 通过sysfs文件系统来完成

<li>
  支持热插拔设备

<li>
  设备分类， /sys/class

<li>
  对象生命周期, kobject是设备模式中最底层的数据结构

</ol>

<h1 id="toc_1">kobject， kset， subsystem</h1>
<p>
Linux设备模型的底层结构， 它们是组成设备模型的砖块!!!
</p>

<h2 id="toc_1.1">kobject</h2>
<pre>
    struct kobject 
    {
        char * k_name;  //指向设备名称的指针
        char name[KOBJ_NAME_LEN];   //设备名称
        struct kref kref;   //对象引用计数
        struct list_head entry; //链接所有kset中的单元
        struct kobject *parent; //指向父对象的指针， kset.kobj
        struct kset *kset;      //所属kset的指针
        struct kobj_type *ktype;    //指向其对象类型描述符的指针
        struct dentry *dentry;      //sysfs文件系统中与该对象对应的文件节点路径指针
        wait_queue_head_t poll;   
    }
</pre>
<ul>
<li>
  kobject是组成设备模型的基本结构， 它所支持的代码包括

<ul>
<li>
  对象的引用计数

<li>
  sysfs表述， sysfs中显示的每一个对象， 都对应一个kobject

<li>
  数据结构关联

<li>
  热插拔事件处理， 在kobject子系统控制下， 将产生事件以通知用户空间

</ul>
<li>
  内核用kobject结构将各个对象连接起来组成一个分层的结构体系， 从而与模型化的子系统相匹配   

<li>
  kobject中的parent成员， 它保存了另一个kobject结构指针， 该结构表示分层结构中上一层的节点

<li>
  Functions：

<ul>
<li>
  kobject_init

<li>
  kobject_set_name

<li>
  kobject_get

<li>
  kobject_put

<li>
  struct kobj_type中包含Release函数

</ul>
<li>
  kobj_type

<ul>
<li>
  它用于说明kobject结构的类型
<pre>
    struct kobj_type
    {
        void (*release)(struct kobject*);   //注销函数指针
        struct sysfs_ops *sysfs_ops;        //指向如何读写的函数指针
        struct attribute **defalut_attrs;   //属性列表
    }
</pre>

</ul>
<li>
  Attribute

<ul>
<li>
  在sysfs中， kobject对应目录， 属性对应文件
<pre>
    struct attribute
    {
        const char *name;       //attribute以文件形式输出到sysfs的目录中对应的文件名
        struct module *owner;   
        mode_t mode;
    }
</pre>

</ul>
</ul>

<h2 id="toc_1.2">kset</h2>
<pre>
    struct kset
    {
        struct kobj_type *ktype;    //指向该kset对象类型的描述符的指针
        struct list_head list;      //用于连接该set中所有kobject的链表头
        spinlock_t list_lock;       //互斥访问 
        struct kobject kobj;        //嵌入的kobject， 所有属于该kset的kobject对象的parent域均指向这个内嵌对象
        struct kset_uevent_ops *uevent_ops;
    }
</pre>
<ul>
<li>
  kset： 一个kset是嵌入相同类型结构的kobject集合， 可看作是顶层容器类

<li>
  kset总是在sysfs中出现， 一旦设置了kset并把它添加到系统中， 将在sysfs中创建一个目录。

<li>
  kset在一个标准的内核链表中保存了它的子节点

<li>
  Functions：

<ul>
<li>
  kset_init

<li>
  kset_add

<li>
  kset_register

<li>
  kset_unregister

<li>
  kset_get

<li>
  kset_put

</ul>
<li>
  kset也有一个指针指向kobj_type结构， 用来描述它所包含的kobject

<li>
  kset包含了一个子系统指针(subsys)

<li>
  每一个kset都必须以属于一个子系统

<li>
  相同类型(kobj_type)的kobject集合在一起组成kset, 许多kset(可以是不同类型)集合在一起组成了子系统

</ul>

<h2 id="toc_1.3">子系统 </h2>
<ul>
<li>
  子系统是对整个内核中一些高级部分的表示， 通常显示在sysfs分层结构中的顶层。

<li>
  内核中的子系统包括

<ul>
<li>
  block_subsys    对块设备来说是/sys/block

<li>
  devices_subsys  设备分层结构的核心， /sys/devices

<li>
  内核所知晓的用于各种总线的特定子系统

</ul>
<li>
  子系统结构定义:     其实是对kset和一个信号量的封装
<pre>
        struct subsystem
        {
            struct kset kset;
            struct rw_semaphore rwsem;
        }
</pre>

<li>
  Functions：

<ul>
<li>
  subsystem_init

<li>
  subsystem_register

<li>
  subsystem_unregister

<li>
  subsystem_get

<li>
  subsystem_put

</ul>
</ul>

<h2 id="toc_1.4">热插拔事件 </h2>
<ul>
<li>
  一个热插拔事件是从内核空间发送到用户空间的通知， 它表明系统配置出现变化。

<li>
  无论是kobject被创建还是被删除， 都会产生这种事情。

<li>
  热插拔事件会导致对/sbin/hotpulg程序的调用， 该程序通过加载驱动程序， 创建设备节点， 挂载分区，或者其它正确的动作来响应该事件 

<li>
  当把kobject传递给kobject_add或者kobject_del时， 才会真正产生这些事件

<li>
  对热插拔事件的控制函数：    在kset结构中的hotplug_ops成员中有指向该结构的指针
<pre>
        struct kset_hotplug_ops
        {
            int (*filter)(struct kset *kset, struct kobject *kobj);
            char *(*name)(struct kset *kset, struct kobject *kobj);
            int (*hotplug)(struct kset *kset, struct kobject *kobj, char **envp, int num_envp, char *buffer, int buffer_size);
        }
</pre>

</ul>

<h1 id="toc_2">Linux设备模型的上层容器 </h1>
<p>
Linux设备模型通过Bus, Device, Device Driver这三个数据结构来描述的!!!
</p>
<h2 id="toc_2.1">Bus</h2>
<ul>
<li>
  总线是处理器与一个或多个设备之间的通道， 在设备模型中， 所有设备都是通过总线相连， 甚至包括“虚拟”平台总线

<li>
  总线结构
<pre>
        struct bus_type
        {
            char *name;             //总线名字， 如PCI， USB
            struct subsystem subsys;    //每个总线都有自己的子系统  
            struct kset drivers;        //总线的驱动程序
            struct kset devices;        //插入总线的所有设备
            int (*match)(struct device *dev, struct device_driver *drv);    //对于真实硬件， 该函数会对设备硬件ID与驱动所支持ID做比较
            struct device *(*add)(struct device *parent, char *bus_id);
            int (*hotplug) (struct device *dev, char **envp, int num_envp, char *buffer, int buffer_size);
            ......
        }
</pre>

<li>
  每个总线都会在sysfs的/sys/bus目录下看到

<li>
  ldd中包含lddbus的虚拟总线

<li>
  内核函数提供对设备和驱动程序的迭代

<ul>
<li>
  bus_for_each_dev

<li>
  bus_for_each_drv

</ul>
<li>
  总线属性， bus_attribute

<ul>
<li>
  BUS_ATTR(name, mode, show, store)        //该宏声明一个结构， 它将bus_attr_作为约定name的前缀来创建总线的真正名称

<li>
  bus_remove_file         //创建属性， 在/sys/bus/ldd/目录下创建一个属性文件

<li>
  bus_delete_file         //删除属性， 删除属性文件

</ul>
</ul>

<h2 id="toc_2.2">Device</h2>
<pre>
    struct device
    {
        struct device *parent;      //总线或宿主控制器
        struct kobject kobj;        //表示该设备并把它连接到结构体系中的kobject
        char bus_id[BUS_ID_SIZE];   //在总线上唯一标识该设备的字符串， 包括：域编号、总线编号、设备编号和功能编号
        struct bus_type *bus;       //标识该设备连接在何种类型的总线上
        struct device_driver *driver;   //管理该设备的驱动程序
        void *driver_data;              //由设备驱动程序使用的私有数据结构， 类似Windows Driver中的context
        void (*release)(struct device *dev);    //当指向设备的最后一个引用被删除时， 内核调用该方法， 它将从内嵌的kobject的release方法中调用
        ......
    }
</pre>
<ul>
<li>
  在注册设备结构前， 至少要设置parent、bus_id、bus和release成员

<li>
  设备注册

<ul>
<li>
  device_register

<li>
  device_unregister

</ul>
<li>
  设备属性

<ul>
<li>
  struct device_attribute

<li>
  DEVICE_ATTR

<li>
  device_create_file

<li>
  device_remove_file

</ul>
<li>
  device结构中包含设备模型核心用来模拟系统的信息， 通常嵌入到设备高层表示之中

</ul>

<h2 id="toc_2.3">Device Driver</h2>
<pre>
    struct device_driver
    {
        char *name;     // 驱动程序的名字， 在sysfs中显示
        struct bus_type *bus;   //驱动程序所操作的总线类型
        struct kobject kobj;    //
        struct list_head devices;   //当前驱动程序能操作的设备链表
        int (*probe)(struct device *dev);   //用来查询特定设备是否存在
        int (*remove)(struct device *dev);  //当设备从系统中删除时调用
        void (*shutdown)(struct device *dev);   //关机时调用该函数关闭设备
    }
</pre>
<ul>
<li>
  Driver注册

<ul>
<li>
  driver_register

<li>
  driver_unregister

</ul>
<li>
  Driver属性

<ul>
<li>
  struct attribute

<li>
  DRIVER_ATTR

<li>
  driver_create_file

<li>
  driver_remove_file

</ul>
<li>
  driver结构通常被包含在高层和总线相关的结构中

</ul>

<h2 id="toc_2.4">Class</h2>
<ul>
<li>
  类是一个设备的高层视图， 它抽象出了低层的实现细节

<li>
  驱动程序核心导出了两个不同的接口来管理类

<ul>
<li>
  class_simple例程

<ul>
<li>
  class_simple_create

<li>
  class_simple_destroy

<li>
  class_simple_device_add

<li>
  class_simple_set_hotplug

<li>
  class_simple_device_remove

</ul>
<li>
  正规类接口

<ul>
<li>
  管理类

<ul>
<li>
  struct class

<li>
  class_register

<li>
  class_unregister

<li>
  struct_attribute

<li>
  CLASS_ATTR(name, mode, show, store)

<li>
  class_create_file

<li>
  class_remove_file

</ul>
<li>
  类设备

<ul>
<li>
  类存在的真正目的， 是给作为类成员的各个设备提供一个窗口

<li>
  struct class_device表示类的成员， 也就是类设备

<li>
  class_device_register

<li>
  class_device_unregister

<li>
  struct class_device_attribute

<li>
  CLASS_DEVICE_ATTR(name, mode, show, store)

<li>
  class_device_create_file

<li>
  class_device_remove_file

</ul>
</ul>
</ul>
<li>
  类接口  &lt;--&gt;  类似于Windows Driver中的class interface概念？？？

<ul>
<li>
  设备模型其它部分没有的附加概念

<li>
  一种设备加入或者离开类时获得信息的触发机制

<li>
  struct class_interface

<li>
  class_interface_register

<li>
  class_interface_unregister

<li>
  可为单个类注册多个接口

</ul>
</ul>


   <hr />
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'rickhuang'; // required: replace example with your forum shortname

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</body>
</html>
